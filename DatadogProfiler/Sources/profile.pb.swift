/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2019-Present Datadog, Inc.
 */
 
 // DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: profile.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Profile is a common stacktrace profile format.
//
// Measurements represented with this format should follow the
// following conventions:
//
// - Consumers should treat unset optional fields as if they had been
//   set with their default value.
//
// - When possible, measurements should be stored in "unsampled" form
//   that is most useful to humans.  There should be enough
//   information present to determine the original sampled values.
//
// - On-disk, the serialized proto must be gzip-compressed.
//
// - The profile is represented as a set of samples, where each sample
//   references a sequence of locations, and where each location belongs
//   to a mapping.
// - There is a N->1 relationship from sample.location_id entries to
//   locations. For every sample.location_id entry there must be a
//   unique Location with that id.
// - There is an optional N->1 relationship from locations to
//   mappings. For every nonzero Location.mapping_id there must be a
//   unique Mapping with that id.

internal import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Perftools_Profiles_Profile: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A description of the samples associated with each Sample.value.
  /// For a cpu profile this might be:
  ///   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
  /// For a heap profile, this might be:
  ///   [["allocations","count"], ["space","bytes"]],
  /// If one of the values represents the number of events represented
  /// by the sample, by convention it should be at index 0 and use
  /// sample_type.unit == "count".
  var sampleType: [Perftools_Profiles_ValueType] = []

  /// The set of samples recorded in this profile.
  var sample: [Perftools_Profiles_Sample] = []

  /// Mapping from address ranges to the image/binary/library mapped
  /// into that address range.  mapping[0] will be the main binary.
  var mapping: [Perftools_Profiles_Mapping] = []

  /// Locations referenced by samples.
  var location: [Perftools_Profiles_Location] = []

  /// Functions referenced by locations.
  var function: [Perftools_Profiles_Function] = []

  /// A common table for strings referenced by various messages.
  /// string_table[0] must always be "".
  var stringTable: [String] = []

  /// frames with Function.function_name fully matching the following
  /// regexp will be dropped from the samples, along with their successors.
  var dropFrames: Int64 = 0

  /// frames with Function.function_name fully matching the following
  /// regexp will be kept, even if it matches drop_frames.
  var keepFrames: Int64 = 0

  /// Time of collection (UTC) represented as nanoseconds past the epoch.
  var timeNanos: Int64 = 0

  /// Duration of the profile, if a duration makes sense.
  var durationNanos: Int64 = 0

  /// The kind of events between sampled occurrences.
  /// e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
  var periodType: Perftools_Profiles_ValueType {
    get {return _periodType ?? Perftools_Profiles_ValueType()}
    set {_periodType = newValue}
  }
  /// Returns true if `periodType` has been explicitly set.
  var hasPeriodType: Bool {return self._periodType != nil}
  /// Clears the value of `periodType`. Subsequent reads from it will return its default value.
  mutating func clearPeriodType() {self._periodType = nil}

  /// The number of events between sampled occurrences.
  var period: Int64 = 0

  /// Free-form text associated with the profile. The text is displayed as is
  /// to the user by the tools that read profiles (e.g. by pprof). This field
  /// should not be used to store any machine-readable information, it is only
  /// for human-friendly content. The profile must stay functional if this field
  /// is cleaned.
  var comment: [Int64] = []

  /// Index into the string table of the type of the preferred sample
  /// value. If unset, clients should default to the last sample value.
  var defaultSampleType: Int64 = 0

  /// Documentation link for this profile. The URL must be absolute,
  /// e.g., http://pprof.example.com/cpu-profile.html
  ///
  /// The URL may be missing if the profile was generated by older code or code
  /// that did not bother to supply a link.
  var docURL: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _periodType: Perftools_Profiles_ValueType? = nil
}

/// ValueType describes the semantics and measurement units of a value.
struct Perftools_Profiles_ValueType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index into string table.
  var type: Int64 = 0

  /// Index into string table.
  var unit: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Each Sample records values encountered in some program
/// context. The program context is typically a stack trace, perhaps
/// augmented with auxiliary information like the thread-id, some
/// indicator of a higher level request being handled etc.
struct Perftools_Profiles_Sample: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ids recorded here correspond to a Profile.location.id.
  /// The leaf is at location_id[0].
  var locationID: [UInt64] = []

  /// The type and unit of each value is defined by the corresponding
  /// entry in Profile.sample_type. All samples must have the same
  /// number of values, the same as the length of Profile.sample_type.
  /// When aggregating multiple samples into a single sample, the
  /// result has a list of values that is the element-wise sum of the
  /// lists of the originals.
  var value: [Int64] = []

  /// label includes additional context for this sample. It can include
  /// things like a thread id, allocation size, etc.
  ///
  /// NOTE: While possible, having multiple values for the same label key is
  /// strongly discouraged and should never be used. Most tools (e.g. pprof) do
  /// not have good (or any) support for multi-value labels. And an even more
  /// discouraged case is having a string label and a numeric label of the same
  /// name on a sample.  Again, possible to express, but should not be used.
  var label: [Perftools_Profiles_Label] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Perftools_Profiles_Label: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index into string table. An annotation for a sample (e.g.
  /// "allocation_size") with an associated value.
  /// Keys with "pprof::" prefix are reserved for internal use by pprof.
  var key: Int64 = 0

  /// At most one of the following must be present
  var str: Int64 = 0

  var num: Int64 = 0

  /// Should only be present when num is present.
  /// Specifies the units of num.
  /// Use arbitrary string (for example, "requests") as a custom count unit.
  /// If no unit is specified, consumer may apply heuristic to deduce the unit.
  /// Consumers may also  interpret units like "bytes" and "kilobytes" as memory
  /// units and units like "seconds" and "nanoseconds" as time units,
  /// and apply appropriate unit conversions to these.
  var numUnit: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Perftools_Profiles_Mapping: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique nonzero id for the mapping.
  var id: UInt64 = 0

  /// Address at which the binary (or DLL) is loaded into memory.
  var memoryStart: UInt64 = 0

  /// The limit of the address range occupied by this mapping.
  var memoryLimit: UInt64 = 0

  /// Offset in the binary that corresponds to the first mapped address.
  var fileOffset: UInt64 = 0

  /// The object this entry is loaded from.  This can be a filename on
  /// disk for the main binary and shared libraries, or virtual
  /// abstractions like "[vdso]".
  var filename: Int64 = 0

  /// A string that uniquely identifies a particular program version
  /// with high probability. E.g., for binaries generated by GNU tools,
  /// it could be the contents of the .note.gnu.build-id field.
  var buildID: Int64 = 0

  /// The following fields indicate the resolution of symbolic info.
  var hasFunctions_p: Bool = false

  var hasFilenames_p: Bool = false

  var hasLineNumbers_p: Bool = false

  var hasInlineFrames_p: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Describes function and line table debug information.
struct Perftools_Profiles_Location: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique nonzero id for the location.  A profile could use
  /// instruction addresses or any integer sequence as ids.
  var id: UInt64 = 0

  /// The id of the corresponding profile.Mapping for this location.
  /// It can be unset if the mapping is unknown or not applicable for
  /// this profile type.
  var mappingID: UInt64 = 0

  /// The instruction address for this location, if available.  It
  /// should be within [Mapping.memory_start...Mapping.memory_limit]
  /// for the corresponding mapping. A non-leaf address may be in the
  /// middle of a call instruction. It is up to display tools to find
  /// the beginning of the instruction if necessary.
  var address: UInt64 = 0

  /// Multiple line indicates this location has inlined functions,
  /// where the last entry represents the caller into which the
  /// preceding entries were inlined.
  ///
  /// E.g., if memcpy() is inlined into printf:
  ///    line[0].function_name == "memcpy"
  ///    line[1].function_name == "printf"
  var line: [Perftools_Profiles_Line] = []

  /// Provides an indication that multiple symbols map to this location's
  /// address, for example due to identical code folding by the linker. In that
  /// case the line information above represents one of the multiple
  /// symbols. This field must be recomputed when the symbolization state of the
  /// profile changes.
  var isFolded: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Perftools_Profiles_Line: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the corresponding profile.Function for this line.
  var functionID: UInt64 = 0

  /// Line number in source code.
  var line: Int64 = 0

  /// Column number in source code.
  var column: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Perftools_Profiles_Function: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique nonzero id for the function.
  var id: UInt64 = 0

  /// Name of the function, in human-readable form if available.
  var name: Int64 = 0

  /// Name of the function, as identified by the system.
  /// For instance, it can be a C++ mangled name.
  var systemName: Int64 = 0

  /// Source file containing the function.
  var filename: Int64 = 0

  /// Line number in source file.
  var startLine: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "perftools.profiles"

extension Perftools_Profiles_Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Profile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_type"),
    2: .same(proto: "sample"),
    3: .same(proto: "mapping"),
    4: .same(proto: "location"),
    5: .same(proto: "function"),
    6: .standard(proto: "string_table"),
    7: .standard(proto: "drop_frames"),
    8: .standard(proto: "keep_frames"),
    9: .standard(proto: "time_nanos"),
    10: .standard(proto: "duration_nanos"),
    11: .standard(proto: "period_type"),
    12: .same(proto: "period"),
    13: .same(proto: "comment"),
    14: .standard(proto: "default_sample_type"),
    15: .standard(proto: "doc_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sampleType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sample) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mapping) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.location) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.function) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.stringTable) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.dropFrames) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.keepFrames) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.timeNanos) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.durationNanos) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._periodType) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.period) }()
      case 13: try { try decoder.decodeRepeatedInt64Field(value: &self.comment) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.defaultSampleType) }()
      case 15: try { try decoder.decodeSingularInt64Field(value: &self.docURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sampleType.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sampleType, fieldNumber: 1)
    }
    if !self.sample.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sample, fieldNumber: 2)
    }
    if !self.mapping.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mapping, fieldNumber: 3)
    }
    if !self.location.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.location, fieldNumber: 4)
    }
    if !self.function.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.function, fieldNumber: 5)
    }
    if !self.stringTable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.stringTable, fieldNumber: 6)
    }
    if self.dropFrames != 0 {
      try visitor.visitSingularInt64Field(value: self.dropFrames, fieldNumber: 7)
    }
    if self.keepFrames != 0 {
      try visitor.visitSingularInt64Field(value: self.keepFrames, fieldNumber: 8)
    }
    if self.timeNanos != 0 {
      try visitor.visitSingularInt64Field(value: self.timeNanos, fieldNumber: 9)
    }
    if self.durationNanos != 0 {
      try visitor.visitSingularInt64Field(value: self.durationNanos, fieldNumber: 10)
    }
    try { if let v = self._periodType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if self.period != 0 {
      try visitor.visitSingularInt64Field(value: self.period, fieldNumber: 12)
    }
    if !self.comment.isEmpty {
      try visitor.visitPackedInt64Field(value: self.comment, fieldNumber: 13)
    }
    if self.defaultSampleType != 0 {
      try visitor.visitSingularInt64Field(value: self.defaultSampleType, fieldNumber: 14)
    }
    if self.docURL != 0 {
      try visitor.visitSingularInt64Field(value: self.docURL, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Perftools_Profiles_Profile, rhs: Perftools_Profiles_Profile) -> Bool {
    if lhs.sampleType != rhs.sampleType {return false}
    if lhs.sample != rhs.sample {return false}
    if lhs.mapping != rhs.mapping {return false}
    if lhs.location != rhs.location {return false}
    if lhs.function != rhs.function {return false}
    if lhs.stringTable != rhs.stringTable {return false}
    if lhs.dropFrames != rhs.dropFrames {return false}
    if lhs.keepFrames != rhs.keepFrames {return false}
    if lhs.timeNanos != rhs.timeNanos {return false}
    if lhs.durationNanos != rhs.durationNanos {return false}
    if lhs._periodType != rhs._periodType {return false}
    if lhs.period != rhs.period {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.defaultSampleType != rhs.defaultSampleType {return false}
    if lhs.docURL != rhs.docURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Perftools_Profiles_ValueType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValueType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "unit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.unit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt64Field(value: self.type, fieldNumber: 1)
    }
    if self.unit != 0 {
      try visitor.visitSingularInt64Field(value: self.unit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Perftools_Profiles_ValueType, rhs: Perftools_Profiles_ValueType) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Perftools_Profiles_Sample: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sample"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "location_id"),
    2: .same(proto: "value"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.locationID) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.value) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locationID.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.locationID, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitPackedInt64Field(value: self.value, fieldNumber: 2)
    }
    if !self.label.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.label, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Perftools_Profiles_Sample, rhs: Perftools_Profiles_Sample) -> Bool {
    if lhs.locationID != rhs.locationID {return false}
    if lhs.value != rhs.value {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Perftools_Profiles_Label: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Label"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "str"),
    3: .same(proto: "num"),
    4: .standard(proto: "num_unit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.str) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.num) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.numUnit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularInt64Field(value: self.key, fieldNumber: 1)
    }
    if self.str != 0 {
      try visitor.visitSingularInt64Field(value: self.str, fieldNumber: 2)
    }
    if self.num != 0 {
      try visitor.visitSingularInt64Field(value: self.num, fieldNumber: 3)
    }
    if self.numUnit != 0 {
      try visitor.visitSingularInt64Field(value: self.numUnit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Perftools_Profiles_Label, rhs: Perftools_Profiles_Label) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.str != rhs.str {return false}
    if lhs.num != rhs.num {return false}
    if lhs.numUnit != rhs.numUnit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Perftools_Profiles_Mapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Mapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "memory_start"),
    3: .standard(proto: "memory_limit"),
    4: .standard(proto: "file_offset"),
    5: .same(proto: "filename"),
    6: .standard(proto: "build_id"),
    7: .standard(proto: "has_functions"),
    8: .standard(proto: "has_filenames"),
    9: .standard(proto: "has_line_numbers"),
    10: .standard(proto: "has_inline_frames"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.memoryStart) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.memoryLimit) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.fileOffset) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.filename) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.buildID) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hasFunctions_p) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hasFilenames_p) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.hasLineNumbers_p) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.hasInlineFrames_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.memoryStart != 0 {
      try visitor.visitSingularUInt64Field(value: self.memoryStart, fieldNumber: 2)
    }
    if self.memoryLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.memoryLimit, fieldNumber: 3)
    }
    if self.fileOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.fileOffset, fieldNumber: 4)
    }
    if self.filename != 0 {
      try visitor.visitSingularInt64Field(value: self.filename, fieldNumber: 5)
    }
    if self.buildID != 0 {
      try visitor.visitSingularInt64Field(value: self.buildID, fieldNumber: 6)
    }
    if self.hasFunctions_p != false {
      try visitor.visitSingularBoolField(value: self.hasFunctions_p, fieldNumber: 7)
    }
    if self.hasFilenames_p != false {
      try visitor.visitSingularBoolField(value: self.hasFilenames_p, fieldNumber: 8)
    }
    if self.hasLineNumbers_p != false {
      try visitor.visitSingularBoolField(value: self.hasLineNumbers_p, fieldNumber: 9)
    }
    if self.hasInlineFrames_p != false {
      try visitor.visitSingularBoolField(value: self.hasInlineFrames_p, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Perftools_Profiles_Mapping, rhs: Perftools_Profiles_Mapping) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.memoryStart != rhs.memoryStart {return false}
    if lhs.memoryLimit != rhs.memoryLimit {return false}
    if lhs.fileOffset != rhs.fileOffset {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.buildID != rhs.buildID {return false}
    if lhs.hasFunctions_p != rhs.hasFunctions_p {return false}
    if lhs.hasFilenames_p != rhs.hasFilenames_p {return false}
    if lhs.hasLineNumbers_p != rhs.hasLineNumbers_p {return false}
    if lhs.hasInlineFrames_p != rhs.hasInlineFrames_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Perftools_Profiles_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "mapping_id"),
    3: .same(proto: "address"),
    4: .same(proto: "line"),
    5: .standard(proto: "is_folded"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.mappingID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.line) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isFolded) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.mappingID != 0 {
      try visitor.visitSingularUInt64Field(value: self.mappingID, fieldNumber: 2)
    }
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 3)
    }
    if !self.line.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.line, fieldNumber: 4)
    }
    if self.isFolded != false {
      try visitor.visitSingularBoolField(value: self.isFolded, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Perftools_Profiles_Location, rhs: Perftools_Profiles_Location) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.mappingID != rhs.mappingID {return false}
    if lhs.address != rhs.address {return false}
    if lhs.line != rhs.line {return false}
    if lhs.isFolded != rhs.isFolded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Perftools_Profiles_Line: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Line"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_id"),
    2: .same(proto: "line"),
    3: .same(proto: "column"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.functionID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.line) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.column) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.functionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.functionID, fieldNumber: 1)
    }
    if self.line != 0 {
      try visitor.visitSingularInt64Field(value: self.line, fieldNumber: 2)
    }
    if self.column != 0 {
      try visitor.visitSingularInt64Field(value: self.column, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Perftools_Profiles_Line, rhs: Perftools_Profiles_Line) -> Bool {
    if lhs.functionID != rhs.functionID {return false}
    if lhs.line != rhs.line {return false}
    if lhs.column != rhs.column {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Perftools_Profiles_Function: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Function"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "system_name"),
    4: .same(proto: "filename"),
    5: .standard(proto: "start_line"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.systemName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.filename) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.startLine) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.name != 0 {
      try visitor.visitSingularInt64Field(value: self.name, fieldNumber: 2)
    }
    if self.systemName != 0 {
      try visitor.visitSingularInt64Field(value: self.systemName, fieldNumber: 3)
    }
    if self.filename != 0 {
      try visitor.visitSingularInt64Field(value: self.filename, fieldNumber: 4)
    }
    if self.startLine != 0 {
      try visitor.visitSingularInt64Field(value: self.startLine, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Perftools_Profiles_Function, rhs: Perftools_Profiles_Function) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.systemName != rhs.systemName {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.startLine != rhs.startLine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
